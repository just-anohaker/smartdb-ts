import { Nullable, MaybeUndefined, FilterFunction, Entity, JsonObject } from "./Common";
import { EntityKey, NormalizedEntityKey, ModelSchema } from "./Model";
import { SqlCondition, SqlOrder, SqlResultRange } from "./sqldb/SqlBuilder";
import { DbConnection, DBTransaction } from "./sqldb/DbConnection";
import { LoadChangesHistoryAction } from "./tracker/BasicEntityTracker";
import { ChangesHistoryItem } from "./tracker/EntityTracker";
export interface DbSessionOptions {
    name?: string;
    maxHistoryVersionsHold?: number;
}
export declare class DbSession {
    private connection;
    static DEFAULT_HISTORY_VERSION_HOLD: number;
    private unconfirmedLocks;
    private confirmedLocks;
    private sqlBuilder;
    private schemas;
    private sessionCache;
    private sessionSerial;
    private entityTracker;
    private trackerSqlBuilder;
    private log;
    constructor(connection: DbConnection, onLoadHistory: Nullable<LoadChangesHistoryAction>, sessionOptions: DbSessionOptions);
    readonly isOpen: boolean;
    syncSchema<T extends object>(schema: ModelSchema<T>): void;
    updateSchema<T extends object>(schema: ModelSchema<T>): Promise<void>;
    registerSchema(...schemas: ModelSchema<Entity>[]): void;
    initSerial(serial: number): Promise<void>;
    close(): Promise<void>;
    getAll<T extends object>(schema: ModelSchema<T>, filters?: FilterFunction<T>): T[];
    loadAll<T extends object>(schema: ModelSchema<T>): T[];
    getMany<T extends object>(schema: ModelSchema<T>, condition: SqlCondition, cond?: boolean): Promise<T[]>;
    query<T extends object>(schema: ModelSchema<T>, condition: SqlCondition, resultRange?: SqlResultRange, sort?: SqlOrder, fields?: string[], join?: JsonObject): Promise<T[]>;
    queryByJson<T extends object>(schema: ModelSchema<T>, params: JsonObject): Promise<T[]>;
    exists<T extends object>(schema: ModelSchema<T>, condition: SqlCondition): Promise<boolean>;
    count<T extends object>(schema: ModelSchema<T>, condition: SqlCondition): Promise<number>;
    create<T extends object>(schema: ModelSchema<T>, key: EntityKey<T>): T;
    load<T extends object>(schema: ModelSchema<T>, key: EntityKey<T>): Promise<MaybeUndefined<T>>;
    loadSync<T extends object>(schema: ModelSchema<T>, key: EntityKey<T>): MaybeUndefined<T>;
    getChanges(): ChangesHistoryItem<Entity>[];
    getTrackingOrCachedEntity<T extends object>(schema: ModelSchema<T>, key: EntityKey<T>): MaybeUndefined<T>;
    getCachedEntity<T extends object>(schema: ModelSchema<T>, key: EntityKey<T>): MaybeUndefined<T>;
    lockInThisSession(lockName: string, notThrow?: boolean): boolean;
    saveChanges(serial?: number): Promise<number>;
    rollbackChanges(serial: number): Promise<number>;
    update<T extends object>(schema: ModelSchema<T>, key: NormalizedEntityKey<T>, modifier: Partial<T>): void;
    increase<T extends object>(schema: ModelSchema<T>, key: NormalizedEntityKey<T>, increasements: Partial<T>): Partial<T>;
    delete<T extends object>(schema: ModelSchema<T>, key: NormalizedEntityKey<T>): void;
    beginTransactions(): Promise<DBTransaction>;
    beginEntityTransaction(): void;
    commitEntityTransaction(): void;
    rollbackEntityTransaction(): void;
    private static setToString;
    private trackPersistentEntities;
    private reset;
    private undefinedIfDeleted;
    private queryEntities;
    private queryEntitiesSync;
    private replaceJsonProperties;
    private replaceEntitiesJsonProperties;
    private makeByKeyCondition;
    private loadEntityByKey;
    private loadEntityByKeySync;
    private normalizeEntityKey;
    private getCached;
    private clearLocks;
    private confirmLocks;
    private ensureEntityTracking;
}
